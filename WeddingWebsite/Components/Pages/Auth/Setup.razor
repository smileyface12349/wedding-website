@page "/Account/Setup"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.Identity.EntityFrameworkCore
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.EntityFrameworkCore
@using WeddingWebsite.Components.Sections
@using WeddingWebsite.Core
@using WeddingWebsite.Data

@inject UserManager<Account> UserManager
@inject IUserStore<Account> UserStore
@inject ILogger<Register> Logger
@inject SignInManager<Account> SignInManager
@inject IdentityRedirectManager RedirectManager
@inject RoleManager<IdentityRole> RoleManager

@attribute [AllowAnonymous]

<Section>
    
    <h1>Account Setup</h1>

    <p>This page is used to create an admin user to get you started. Once there exists a user in the database, this page will not work. If it will give you any extra peace of mind, you can delete this page entirely after adding an admin user.</p>

    <p>This is different from the normal registration page which permits admin users only, and should be used in future.</p>
    
    <p>Please note this user will be created with no guests. It is entirely valid to have accounts to permit login and even admin access that do not have any invited guests attached to the account.</p>

    <div class="row">
        <div class="col-md-4">
            <p>@Message</p>
            <EditForm Model="Input" asp-route-returnUrl="/" method="post" OnValidSubmit="RegisterUser" FormName="register">
                <DataAnnotationsValidator />
                <h2>Create an admin account</h2>
                <p>A reminder to choose a secure password, as this account will have admin access!</p>
                <hr style="margin-bottom: 5px" />
                <ValidationSummary class="text-danger" role="alert" />
                <div class="form-floating">
                    <label for="email">Email</label>
                    <MudSpacer/>
                    <InputText @bind-Value="Input.Email" class="form-control" autocomplete="username" aria-required="true" placeholder="name@example.com" id="email"/>
                    <ValidationMessage For="() => Input.Email" class="text-danger" />
                </div>
                @* <div class="form-floating"> *@
                @*     <label for="username">Username (Generally first name and surname, but up to you. May be used in the user interface. No need to be unique.)</label> *@
                @*     <MudSpacer/> *@
                @*     <InputText @bind-Value="Input.UserName" class="form-control" aria-required="true" placeholder="John Smith" id="username"/> *@
                @*     <ValidationMessage For="() => Input.UserName" class="text-danger" /> *@
                @* </div> *@
                <div class="form-floating">
                    <label for="password">Password</label>
                    <MudSpacer/>
                    <InputText type="password" @bind-Value="Input.Password" class="form-control" autocomplete="new-password" aria-required="true" placeholder="password" id="password" />
                    <ValidationMessage For="() => Input.Password" class="text-danger" />
                </div>
                <div class="form-floating mb-3">
                    <label for="confirm-password">Confirm Password</label>
                    <MudSpacer/>
                    <InputText type="password" @bind-Value="Input.ConfirmPassword" class="form-control" autocomplete="new-password" aria-required="true" placeholder="password" id="confirm-password" />
                    <ValidationMessage For="() => Input.ConfirmPassword" class="text-danger" />
                </div>
                <button type="submit">Register</button>
            </EditForm>
        </div>
    </div>
    
</Section>

@code {
    private IEnumerable<IdentityError>? identityErrors;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    private string? Message => identityErrors is null ? null : $"Error: {string.Join(", ", identityErrors.Select(error => error.Description))}";

    protected override async Task OnInitializedAsync()
    {
        await RedirectIfUsersExist();
    }
    
    private async Task<bool> RedirectIfUsersExist()
    {
        var anyUsers = await UserManager.Users.AnyAsync();
        if (anyUsers)
        {
            RedirectManager.RedirectTo("/");
            return true;
        }

        return false;
    }

    public async Task RegisterUser(EditContext editContext)
    {
        // Check if there are any users already - if so, don't allow setup
        if (await RedirectIfUsersExist()) return;
        
        // Create the admin role if it doesn't exist
        if (!await RoleManager.RoleExistsAsync("Admin"))
        {
            var roleResult = await RoleManager.CreateAsync(new IdentityRole("Admin"));
            if (!roleResult.Succeeded)
            {
                identityErrors = roleResult.Errors;
                return;
            }
        }
        
        Logger.LogInformation("Registering a new admin user.");
    
        var user = CreateUser();

        await UserStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);
        await UserManager.AddToRoleAsync(user, "Admin");
        var emailStore = GetEmailStore();
        await emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None);
        var result = await UserManager.CreateAsync(user, Input.Password);

        if (!result.Succeeded)
        {
            identityErrors = result.Errors;
            return;
        }

        Logger.LogInformation("User created a new account with password.");

        var userId = await UserManager.GetUserIdAsync(user);
        var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));

        await SignInManager.SignInAsync(user, isPersistent: false);
        RedirectManager.RedirectTo("/");
    }

    private Account CreateUser()
    {
        try
        {
            return Activator.CreateInstance<Account>();
        }
        catch
        {
            throw new InvalidOperationException($"Can't create an instance of '{nameof(Account)}'. " +
                $"Ensure that '{nameof(Account)}' is not an abstract class and has a parameterless constructor.");
        }
    }

    private IUserEmailStore<Account> GetEmailStore()
    {
        if (!UserManager.SupportsUserEmail)
        {
            throw new NotSupportedException("The default UI requires a user store with email support.");
        }
        return (IUserEmailStore<Account>)UserStore;
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        [Display(Name = "Email")]
        public string Email { get; set; } = "";
        
        // [Required]
        // [Display(Name = "Username")]
        // public string UserName { get; set; } = "";

        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        [Display(Name = "Password")]
        public string Password { get; set; } = "";

        [DataType(DataType.Password)]
        [Display(Name = "Confirm password")]
        [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
        public string ConfirmPassword { get; set; } = "";
    }
}
